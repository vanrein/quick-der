/*
 * Test Quick-DER by dumping some LDAP messages.
 *
 * This code is intended to be an exhaustively documented example of the
 * kinds of things you can do with Quick-DER when dealing with binary data.
 * Note that these are not necessarily always the effective or efficient
 * ways of dealing with that data; this is more of an API showcase.
 *
 * Run this program with a single filename as argument. The file is
 * read, and assumed to be a DER-encoded LDAP message. The LDAP message
 * is explained on stdout.
 */

/*
 *  Copyright 2017, Adriaan de Groot <groot@kde.org>
 *
 *  Redistribution and use is allowed according to the terms of the two-clause BSD license.
 *     https://opensource.org/licenses/BSD-2-Clause
 *     SPDX short identifier: BSD-2-Clause
 */

/* Since we're dealing with LDAP, defined in RFC4211, use that header. */
#include <quick-der/rfc4511.h>
#include <arpa2/quick-der.h>

#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <sys/types.h>
#include <sys/stat.h>

#include "qd-int.h"

const char usage[] = "Usage: ldapsearch.test <filename>\nReads filename and uses Quick-DER to dump the LDAP message inside.\n";

/* Reads a given @p filename and returns a freshly-allocated buffer
 * containing the contents of that file. File must be < 16k in size.
 * The buffer becomes owned by the caller, who should free() it
 * eventually. Returns NULL on any error and prints error reasons
 * to stderr.
 *
 * If @p filesize is non-NULL, it is updated to reflect the size
 * of data read (e.g. the size of the returned buffer), or updated
 * to -1 on any error.
 */
uint8_t *load_file(const char *filename, ssize_t *filesize)
{
	if (filesize)
	{
		*filesize = -1;
	}

	int fd;
	if ((fd = open(filename, O_RDONLY)) < 0)
	{
		perror("Input file open():");
		fputs(usage, stderr);
		return NULL;
	}

	struct stat sb;
	if (fstat(fd, &sb) < 0)
	{
		perror("Input file stat():");
		close(fd);
		return NULL;
	}

	if (sb.st_size > 16384)
	{
		close(fd);
		fputs("-- Input file is too large.\n", stderr);
		return NULL;
	}
	if (sb.st_size < 1)
	{
		close(fd);
		fputs("-- Input file is empty.\n", stderr);
		return NULL;
	}

	uint8_t *buffer = malloc(sb.st_size);
	if (!buffer)
	{
		perror("Input file malloc():");
		close(fd);
		return NULL;
	}

	ssize_t readsize = read(fd, buffer, sb.st_size);
	if (readsize < 0)
	{
		perror("Input file read():");
		close(fd);
		free(buffer);
		return NULL;
	}
	close(fd);
	if (readsize != sb.st_size)
	{
		free(buffer);
		fputs("-- Input file was not fully read.\n", stderr);
		return NULL;
	}

	if (filesize)
	{
		*filesize = sb.st_size;
	}
	return buffer;
}

/* These are the unpacking instructions for an LDAP message, which
 * will be used in ldapdecode() below -- these unpacking instructions
 * are generated by asn2quickder. Note that DER_PACK_END (0) is required,
 * otherwise unpacking will walk off the end of the instructions.
 */
static const derwalk rq_walk[] = { DER_PACK_rfc4511_LDAPMessage, DER_PACK_END };

/* Forward declarations of more specialized decoding functions. */
int ldapdecode_search(const DER_OVLY_rfc4511_SearchRequest *rq);
int ldapdecode_searchresult(const DER_OVLY_rfc4511_SearchResultEntry *rq);

/*
 * Consider a typical Quick-DER generated typedef,
 *
 *     typedef struct {
 *       DER_OVLY_rfc4511_LDAPDN entry; // LDAPDN
 *       DER_OVLY_rfc4511_AttributeList attributes; // AttributeList
 *     } DER_OVLY_rfc4511_AddRequest;
 *
 * Expanding the typedefs recursively, we'll eventually find out
 * that the first member of member DER_OVLY_rfc4511_AddRequest.entry
 * is a dercursor. Since all the typedefs en up just being, in memory,
 * arrays of dercursor structs, here's a type-casting hammer to smash
 * them to dercursor pointers regardless of how deep the types are
 * nested.
 */
#define DER_CAST_CURSOR(x) ((dercursor *)(&(x)))

/*
 * Treats a given buffer @p message with size @p message_size (probably
 * returned from load_file(), above) as an LDAPMessage and tries to
 * unpack the Message. It then dumps the information that it knows
 * about the message to stdout.
 *
 * Returns the same as der_unpack() -- 0 for success, <0 on failure.
 */
int ldapdecode(uint8_t *message, ssize_t message_size)
{
	/* We're going to treat the whole message as a DER-encoded LDAPMessage */
	dercursor crs;
	crs.derptr = message;
	crs.derlen = message_size;

	/* For unpacking, we need the structure to unpack to, and the
	 * packing instructions (see above -- rq_walk). Assume there's only
	 * one message to unpack.
	 */
	DER_OVLY_rfc4511_LDAPMessage rq;

	int r = der_unpack(&crs, rq_walk, (dercursor *) &rq, 1);
	if (r < 0)
	{
		return r;
	}
	if (message_size != (crs.derptr - message))
	{
		fprintf(stderr,"! Message was not completely consumed: %zd bytes left.", message_size - (crs.derptr - message));
		return -1;
	}

	if (!rq.messageID.derptr || (rq.messageID.derlen > 4) || (rq.messageID.derlen < 1))
	{
		fprintf(stderr, "! Unusual message ID length %d.\n", (int)rq.messageID.derlen);
		return -1;
	}

	int32_t messageID;
	if (!der_get_int32(rq.messageID, &messageID))
	{
		fprintf(stdout, ".. Message ID=%d", messageID);  /* No \n, completed below when looking at protocolOp */
	}
	else
	{
		fprintf(stderr, "! Unpacking message ID failed.\n");
		return -1;
	}

	/* Note that this means of walking an LDAPMessage -- in one go with
	 * the top-level DER_PACK_rfc4511_LDAPMessage -- isn't really
	 * convenient: we now need to find out which choice has been
	 * made for protocolOp, and that means futzing through the
	 * sub-structures looking for a non-null pointer.
	 *
	 * We know, though, that every structure is just one or more
	 * dercursor structures internally, so a suitable cast lets
	 * us look at the start of the searchRequest structure to
	 * see if it is filled in; similar for searchResults.
	 */
	if (DER_CAST_CURSOR(rq.protocolOp.searchRequest)->derptr)
	{
		fprintf(stdout, " SearchRequest.\n");
		return ldapdecode_search(&(rq.protocolOp.searchRequest));
	}
	else if (DER_CAST_CURSOR(rq.protocolOp.searchResEntry)->derptr)
	{
		fprintf(stdout, " SearchResult.\n");
		return ldapdecode_searchresult(&(rq.protocolOp.searchResEntry));
	}
	else
	{
		/* TODO: how to determine the tag of this element? */
		fprintf(stdout, " Unknown message type.\n");
		fprintf(stderr, "! Unknown message type.\n");
		return -1;
	}
	return r;
}

/*
 * Recursive decoding of filter expressions. The recursion starts in
 * ldapdecode_filter(), which calls other ldapdecode_*() functions
 * for specialized processing (e.g. for the different operators).
 *
 * Each decoding function takes a dercursor (which points to the bit of
 * DER-encoded filter expression we're working on) and a depth; the
 * depth is used to nicely format the output.
 *
 * Most of the functions also take a label, which is the human-readable
 * name of the operator under consideration, and an indent-string, which
 * is just a convenient way to pass in depth*2 spaces.
 */
int ldapdecode_filter(dercursor inner, int depth);

/*
 * Binary operators take exactly 2 string arguments (AttributeValueAssertion).
 * They don't recurse.
 */
int ldapdecode_binop(const char *label, const char *indent, dercursor crs)
{
	uint8_t tag;
	size_t len;
	uint8_t hlen;
	dercursor first = crs;
	if (der_header(&first, &tag, &len, &hlen) < 0)
	{
		fprintf(stderr, "! Could not read DER header of Filter binary operator element %d.\n", 1);
		return -1;
	}
	if (tag != 0x04) /* String */
	{
		fprintf(stderr, "! Filter binary operator LHS is not a string.\n");
		return -1;
	}
	first.derlen = len;

	dercursor second = crs;
	der_skip(&second);
	if (der_header(&second, &tag, &len, &hlen) < 0)
	{
		fprintf(stderr, "! Could not read DER header of Filter binary operator element %d.\n", 2);
		return -1;
	}
	if (tag != 0x04) /* String */
	{
		fprintf(stderr, "! Filter binary operator RHS is not a string.\n");
		return -1;
	}
	second.derlen = len;

	fprintf(stdout, "    %s (%.*s %s %.*s)\n", indent, (int)first.derlen, first.derptr, label, (int)second.derlen, second.derptr);

	return 0;
}

/*
 * Multi-operators take sequence (or set) of filter expressions to work on.
 * They do recurse.
 */
int ldapdecode_multiop(const char *label, const char *indent, dercursor inner, int depth)
{
	dercursor iter;
	if (der_iterate_first(&inner, &iter) < 0)
	{
		fprintf(stderr, "! Could not enter list-operator %s.\n", label);
		return -1;
	}

	fprintf(stdout, "    %s (%s\n", indent, label);
	while (der_isnonempty(&iter))
	{
		if (ldapdecode_filter(iter, depth+1) < 0)
		{
			return -1;
		}
		der_iterate_next(&iter);
	}
	fprintf(stdout, "    %s )\n", indent);
	return 0;
}

/*
 * Decode an entire filter expression, outputting it to stdout,
 * nicely formated with indentation according to @p depth.
 */
int ldapdecode_filter(dercursor inner, int depth)
{
	static const char _indent[] = "           ";
	const char *indent = (depth <= 5) ? (_indent + 10 - 2 * depth) : _indent;

	uint8_t tag;
	size_t len;
	uint8_t hlen;
	/* Read out the tag values (necessary,
	 * since the tag distinguishes the CHOICE in Filter semantics)
	 * and after that the inner cursor points to the inner
	 * data. Note we use the length returned from the der_header()
	 * call, not what's in inner.derlen, because when coming from
	 * the outer element that derlen is too long (it still counts
	 * the whole length of the outer element).
	 */
	if (der_header(&inner, &tag, &len, &hlen) < 0)
	{
		fprintf(stderr, "! Could not read DER header of Filter element.\n");
		return -1;
	}

	switch (tag)
	{
	case 0xa0: /* and */
		return ldapdecode_multiop("&", indent, inner, depth);
		break;
	case 0xa1: /* or */
		return ldapdecode_multiop("|", indent, inner, depth);
		break;
	case 0xa2: /* not */
		fprintf(stdout, "    %s (%s\n", indent, "!");
		ldapdecode_filter(inner, depth+1);
		fprintf(stdout, "    %s )\n", indent);
		break;
	case 0xa3: /* equality */
		return ldapdecode_binop("==", indent, inner);
		break;
	case 0xa5: /* >= */
		return ldapdecode_binop(">=", indent, inner);
		break;
	case 0xa6: /* <= */
		return ldapdecode_binop("<=", indent, inner);
		break;
	default:
		fprintf(stderr, "! Do not understand filter operation %02x.\n", tag);
		return -1;
	}

	return 0;
}

/*
 * Decode a SearchRequest, outputs some debugging information
 * followed by the search filter in a nicely-formatted way.
 */
int ldapdecode_search(const DER_OVLY_rfc4511_SearchRequest* rq)
{
	static const char indent[] = "  .. ";

	/* Unlikely case, since this overlaps with the dercursor we
	 * checked in the LDAPMessage to decide to call here.
	 */
	if (!rq->baseObject.derptr)
	{
		fprintf(stderr, "! Missing baseObject.\n");
		return -1;
	}

	/* Interpret the INTEGER attributes as uint, since they
	 * are defined as 0..maxInt (2^31 - 1), and interpret
	 * ENUMERATED as uint as well.
	 */
	uint32_t scope, deref, sizelimit, timelimit, types;
	if (der_get_uint32(rq->scope, &scope) < 0)
	{
		fprintf(stderr, "! Scope could not be interpreted.\n");
		return -1;
	}
	if (der_get_uint32(rq->derefAliases, &deref) < 0)
	{
		fprintf(stderr, "! DerefAliases could not be interpreted.\n");
		return -1;
	}
	if (der_get_uint32(rq->sizeLimit, &sizelimit) < 0)
	{
		fprintf(stderr, "! SizeLimit could not be interpreted.\n");
		return -1;
	}
	if (der_get_uint32(rq->timeLimit, &timelimit) < 0)
	{
		fprintf(stderr, "! TimeLimit could not be interpreted.\n");
		return -1;
	}
	if (der_get_uint32(rq->typesOnly, &types) < 0)
	{
		fprintf(stderr, "! TypesOnly could not be interperted.\n");
		return -1;
	}

	fprintf(stdout, "%sBaseObject='%.*s'\n", indent, (int)rq->baseObject.derlen, rq->baseObject.derptr);
	fprintf(stdout, "%sScope=%d\n", indent, scope);
	fprintf(stdout, "%sDerefAliases=%d\n", indent, deref);
	fprintf(stdout, "%sSizeLimit=%d\n", indent, sizelimit);
	fprintf(stdout, "%sTimeLimit=%d\n", indent, timelimit);
	fprintf(stdout, "%sTypesOnly=%d\n", indent, types);

	/*
	 * The filter part is labeled "ANY", and is not taken apart into constituent
	 * parts. So we'll pick apart the filter items one-by-one,
	 * by examining the tags. These are documented in RFC 4511, $4.5.1.
	 */
	if (der_isnonempty(&(rq->filter)))
	{
		fprintf(stdout, "%s Filter=\n", indent);
		if (ldapdecode_filter(rq->filter, 0) < 0)
		{
			return -1;
		}
	}
	return 0;
}

int ldapdecode_searchresult(const DER_OVLY_rfc4511_SearchResultEntry* rq)
{
	fprintf(stderr, "! NotImplemented.\n");
	return -1;
}


int main(int argc, char **argv)
{
	if (argc != 2)
	{
		fputs(usage, stderr);
		fputs("-- Missing file argument.\n", stderr);
		return 1;
	}

	ssize_t buffer_size = 0;
	uint8_t *buffer = load_file(argv[1], &buffer_size);
	if (!buffer)
	{
		/* Error has already been printed */
		return 1;
	}

	int r = ldapdecode(buffer, buffer_size);
	if (r < 0)
	{
		fprintf(stderr, "! Failed, return %d\n", r);
	}

	free(buffer);
	return r ? 1 : 0;
}
