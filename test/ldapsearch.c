/*
 * Test Quick-DER by dumping some LDAP messages.
 *
 * This code is intended to be an exhaustively documented example of the
 * kinds of things you can do with Quick-DER when dealing with binary data.
 *
 * Run this program with a single filename as argument. The file is
 * read, and assumed to be a DER-encoded LDAP message. The LDAP message
 * is explained on stdout.
 */

/*
 *  Copyright 2017, Adriaan de Groot <groot@kde.org>
 *
 *  Redistribution and use is allowed according to the terms of the two-clause BSD license.
 *     https://opensource.org/licenses/BSD-2-Clause
 *     SPDX short identifier: BSD-2-Clause
 */

/* Since we're dealing with LDAP, defined in RFC4211, use that header. */
#include <quick-der/rfc4511.h>
#include <quick-der/api.h>

#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <sys/types.h>
#include <sys/stat.h>

const char usage[] = "Usage: ldapsearch.test <filename>\nReads filename and uses Quick-DER to dump the LDAP message inside.\n";

/* Reads a given @p filename and returns a freshly-allocated buffer
 * containing the contents of that file. File must be < 16k in size.
 * The buffer becomes owned by the caller, who should free() it
 * eventually. Returns NULL on any error and prints error reasons
 * to stderr.
 *
 * If @p filesize is non-NULL, it is updated to reflect the size
 * of data read (e.g. the size of the returned buffer), or updated
 * to -1 on any error.
 */
uint8_t *load_file(const char *filename, ssize_t *filesize)
{
	if (filesize)
	{
		*filesize = -1;
	}

	int fd;
	if ((fd = open(filename, O_RDONLY)) < 0)
	{
		perror("Input file open():");
		fputs(usage, stderr);
		return NULL;
	}

	struct stat sb;
	if (fstat(fd, &sb) < 0)
	{
		perror("Input file stat():");
		close(fd);
		return NULL;
	}

	if (sb.st_size > 16384)
	{
		close(fd);
		fputs("-- Input file is too large.\n", stderr);
		return NULL;
	}
	if (sb.st_size < 1)
	{
		close(fd);
		fputs("-- Input file is empty.\n", stderr);
		return NULL;
	}

	uint8_t *buffer = malloc(sb.st_size);
	if (!buffer)
	{
		perror("Input file malloc():");
		close(fd);
		return NULL;
	}

	ssize_t readsize = read(fd, buffer, sb.st_size);
	if (readsize < 0)
	{
		perror("Input file read():");
		close(fd);
		free(buffer);
		return NULL;
	}
	close(fd);
	if (readsize != sb.st_size)
	{
		free(buffer);
		fputs("-- Input file was not fully read.\n", stderr);
		return NULL;
	}

	if (filesize)
	{
		*filesize = sb.st_size;
	}
	return buffer;
}

/* These are the unpacking instructions for an LDAP message, which
 * will be used in ldapdecode() below -- these unpacking instructions
 * are generated by asn2quickder. Note that DER_PACK_END (0) is required,
 * otherwise unpacking will walk off the end of these instructions.
 */
static const derwalk rq_walk[] = { DER_PACK_rfc4511_LDAPMessage, DER_PACK_END };

/*
 * Treats a given buffer @p message with size @p message_size (probably
 * returned from load_file(), above) as an LDAPMessage and tries to
 * unpack the Message. It then dumps the information that it knows
 * about the message to stdout.
 *
 * Returns the same as der_unpack() -- 0 for success, <0 on failure.
 */
int ldapdecode(uint8_t *message, ssize_t message_size)
{
	/* We're going to treat the whole message as a DER-encoded LDAPMessage */
	dercursor crs;
	crs.derptr = message;
	crs.derlen = message_size;

	/* For unpacking, we need the structure to unpack to, and the
	 * packing instructions (above -- rq_walk). Assume there's only
	 * one message to unpack.
	 */
	DER_OVLY_rfc4511_LDAPMessage rq;

	int r = der_unpack(&crs, rq_walk, (dercursor *) &rq, 1);
	if (r < 0)
	{
		return r;
	}

	fprintf(stdout, ".. Got message ID %p %d\n", (void *)rq.messageID.derptr, (int)rq.messageID.derlen);
	fprintf(stdout, ".. Message cursor %p -> %p, %d bytes used.\n", message, crs.derptr, (int) (crs.derptr - message));
	return r;
}

int main(int argc, char **argv)
{
	if (argc != 2)
	{
		fputs(usage, stderr);
		fputs("-- Missing file argument.\n", stderr);
		return 1;
	}

	ssize_t buffer_size = 0;
	uint8_t *buffer = load_file(argv[1], &buffer_size);
	if (!buffer)
	{
		/* Error has already been printed */
		return 1;
	}

	fprintf(stderr, "%d\n", ldapdecode(buffer, buffer_size));

	free(buffer);
	return 0;
}
